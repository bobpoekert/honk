(ns honk.util
  (import [java.util.concurrent BlockingQueue LinkedBlockingQueue]
          [java.lang.ref WeakReference ReferenceQueue]
          [java.lang.reflect Method]))

(defn queue-seq
  "Takes a queue and wraps it in a lazy seq that takes off the queue. The queue can be closed with close-queue!"
  [^BlockingQueue q]
  (lazy-seq
    (let [head (.take q)]
      (if (= head ::done)
        (do
          (.put q ::done)
          nil)
        (cons head (queue-seq q))))))

(defn close-queue!
  "Causes all queue-seqs taking from the given queue to terminate"
  [^BlockingQueue q]
  (.put q ::done))

(defrecord OAuthCred [consumer-key consumer-secret token secret])

(defn- generate-wrapper-method
  [wrap-field-sym getter ^Method method]
  (let [method-name (symbol (.getName method))
        args (for [arg (.getParameterTypes method)]
              (with-meta (gensym) {:tag arg}))
        this (gensym "this")
        outp-args (into [this] args)
        return-type (.getReturnType method)]
    [method-name
     `(~(with-meta method-name {:tag return-type}) ~outp-args
        (. ~(getter wrap-field-sym this) method-name ~@args))]))

(defn- wrap-interface
  [interface wrap-field-sym getter]
  (into {} (map (partial generate-wrapper-method wrap-field-sym getter)
              (.getDeclaredMethods interface))))

(defn- wrap-interfaces
  [wrap-field-sym getter cls]
  (into {}
    (for [interface (.getInterfaces cls)]
      [(symbol (.getName interface)) (wrap-interface interface wrap-field-sym getter)])))

(defn- specs-to-interfaces
  [specs]
  (into {}
    (for [[iface & meths] (partition-by symbol? specs)]
      [iface (into {} (for [meth meths] [(first meth) meth]))])))

(defmacro defwrapper
  "Generates a wrapper type with the specified name that wraps the specified type.
   Wrapper type will implement all interfaces of wrapped type.
   Any methods of interfaces of the wrapped type will get autogenerated methods in the wrapper that call them."
  [outp-name ^Class wrapped-type fields getter & specs]
  (let [fields (map (comp symbol name) fields) ;; fields shouldn't be namespace-qualified
        getter (if (nil? getter) (fn [field this] `(. ~this ~field)) (eval getter))
        wrap-field-sym (with-meta (gensym "wrapper-this") {:tag wrapped-type})
        given-methods (specs-to-interfaces specs)
        generated-methods (wrap-interfaces wrap-field-sym getter (resolve wrapped-type))
        res-methods (merge-with merge generated-methods given-methods)]
    `(deftype ~outp-name ~(into [wrap-field-sym] fields)
      ~wrapped-type
      ~@(mapcat
          (fn [[typ impl]]
            (cons typ (vals impl)))
          res-methods))))

(defmacro defweakrefwrapper
  [name cls]
  (let [callback '(fn [this field]
                    `(let [v# (.get ~this)]
                      (if (nil? v#)
                        ((. ~this onfree) ~this)
                        (. v# ~field))))]
    `(defwrapper ~name ~cls
      [onfree]
      ~callback)))

(defweakrefwrapper WeakrefQueue java.util.concurrent.BlockingQueue)
